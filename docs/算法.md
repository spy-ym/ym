# 算法
- - - -
## 1.动态规划
- 动态规划的一般流程：
暴力的递归解法->带备忘录的递归解法->迭代的动态规划解法
- 思考方式：
找到状态和选择->明确dp数组/函数的定义->寻找状态之间的关系。
- 一般形式：求最值。
- 求解动态规划的核心问题：穷举。
- 目的：如何正确的穷举（存在重叠子问题）。
- 方法：写出正确的状态转移方程。
- 如何写状态转移方程：
  1. 明确base case
  2. 明确[状态]
  3. 明确[选择]
  4. 定义dp数组/函数的含义。
```c
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

- 注：递归算法的时间复杂度怎么计算：就是用子问题个数乘以解决一个子问题需要的时间。

方法：先根据暴力法找到状态转移方程，然后就是优化（备忘录或者dp table）,进一步优化就是缩小dp table的空间大小。

动态规划问题：具有[最优子结构]，子问题之间必须互相独立。

比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。
得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。
但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

凑零钱问题，为什么说它符合最优子结构呢？比如你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

## 回溯算法
**解决一个回溯问题，实际上就是一个决策树的遍历过程。**
考虑三个问题：
1. 路径：也就是已经做出的选择。
2. 选择列表：也就是你当前可以做的选择。
3. 结束条件：也就是到达决策树底层，无法再做选择的条件(选择列表为空)。


- 前序遍历的代码在进入某一个节点之前的那个时间点执行
- 后序遍历代码在离开某个节点之后的那个时间点执行。
- 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」

回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。
- 算法框架
```
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```

### BFS算法（广度优先遍历）
**问题的本质就是让你在一幅「图」中找到从起点start到终点target的最近距离**
```python
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路
​
    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数
​
    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```